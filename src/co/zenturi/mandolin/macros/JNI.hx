package co.zenturi.mandolin.macros;

import haxe.macro.Expr.Field;
import sys.io.FileSeek;
import haxe.macro.Expr;
import haxe.macro.Context;
import haxe.macro.Type;
import sys.io.File;
import sys.FileSystem;

using StringTools;

class JNI {
	static var moduleName:String;

	static var cppFiles:Array<String> = [];

	static var withImpl:Bool = false;

	/**
	 * Create JNI Native bindings in CPP
	 * @return Array<Field>
	 */
	macro static function bind(hasProxy:Bool = false):Array<Field> {
		var pack = Context.getLocalModule();
		var fields:Array<Field> = Context.getBuildFields();
		JNIClassGen.init(pack, fields, hasProxy);
		return null;
	}

	/**
	 * Forward Java calls from Cpp
	 * @return Array<Field>
	 */
	macro static function proxy():Array<Field> {
		var pack = Context.getLocalModule();
		var unpack = pack.split(".");
		var pathLength = unpack.length;
		cppFiles = [];
		var name = 'Native${unpack[pathLength - 1]}';
		init(name);
		return null;
	}

	static function init(name:String) {
		moduleName = name;
		genJNIProxy();
	}

	static function genJNIProxy() {
		genCppNamespace(createCppdir());
	}

	static function createCppdir() {
		var dir = Sys.getCwd();
		if (!FileSystem.exists('${dir}gen')) {
			if (FileSystem.exists('${dir}gen/cpp')) {
				FileSystem.createDirectory('${dir}gen/cpp');
			}

			FileSystem.createDirectory('${dir}gen');
		}

		return '${dir}/gen/jni';
	}

	static function genCppNamespace(path:String) {
		var dir = Sys.getCwd();

		var pack = Context.getLocalModule();
	
		var pathLength = pack.split(".").length;
		var unpack = pack.split(".");
		var packPath = unpack.slice(0, pathLength - 1).join("/");
		var classPath = '${dir}gen/cpp/$packPath';
		var _name = unpack[pathLength - 1];

		if (!FileSystem.exists(classPath)) {
			FileSystem.createDirectory(classPath);
		}

		File.saveContent('$classPath/$moduleName.cpp', '');

		constructJNINamespace('$classPath/$moduleName.cpp');

		File.saveContent('$classPath/$moduleName.hpp', '');

		constructJNIHeader('$classPath/$moduleName.hpp');

		if (cppFiles.indexOf('$classPath/$moduleName.cpp') == -1) {
			cppFiles.push('$classPath/$moduleName.cpp');
		}

		var buildXml = new StringBuf();

		buildXml.add("<files id='haxe'>\n");
		buildXml.add('<compilerflag value="-I$classPath"/>\n');
		for (cp in cppFiles) {
			buildXml.add('<file name="$cp" />\n');
		}
		buildXml.add("</files>\n");

		var _class = Context.getLocalClass();
		var _pos = Context.currentPos();
		var _pos_info = Context.getPosInfos(_pos);
		_class.get().meta.add(":buildXml", [{expr: EConst(CString('${buildXml.toString()}')), pos: _pos}], _pos);
	}

	static function constructJNINamespace(name:String) {
		var sbuf = new StringBuf();
		var pack = Context.getLocalModule();
		var unpack = pack.split(".");
		var pathLength = unpack.length;
		var _name = '${unpack[pathLength - 1]}';
		var _package = unpack.slice(0, pathLength - 1).join("/");

		var JNIPrefix = 'Java_${_package.replace("/", "_")}_react_${_name}_00024CppProxy_';

		sbuf.add("// AUTOGENERATED FILE - DO NOT MODIFY!\n");
		sbuf.add("// This file is generated by Mandolin - (c) Zenturi.co\n\n");
		sbuf.add('#include "$moduleName.hpp"\n\n');
		sbuf.add("namespace mandolin_generated {\n\n");
		var JavaProxy = "$JavaProxy";
		sbuf.add('$moduleName::$moduleName() : ::mandolin::JniInterface<::$_name, $moduleName> {}\n\n');
		sbuf.add('$moduleName::~$moduleName() = default;\n\n');

		sbuf.add('$moduleName::JavaProxy::JavaProxy(JniType j) : Handle(::mandolin::jniGetThreadEnv(), j) { }\n\n');
		sbuf.add('$moduleName::::JavaProxy::~JavaProxy() = default;\n\n');

		// Fields
		var fields:Array<Field> = Context.getBuildFields();

		var funcs = [];

		for (field in fields) {
			switch field.kind {
				case FFun(f):
					{
						var hasIgnore = false; 
						for (meta in field.meta){
							if(meta.name == "ignore"){
								hasIgnore = true;
							}
						}
						if(hasIgnore) continue;

						var impName = "";
						var re = ~/([-_][a-z])/;
						var fname = field.name;
						if (re.match(field.name)) {
							for (i in 0...re.matchedPos().len) {
								fname = re.replace(field.name, re.matched(i).toUpperCase()).replace("_", "").replace("-", "");
							}
						}

						if (fname == "new") {
							continue;
						}

						var params = [];
						var paramGetters = [];
						var retGetters = [];
						for (arg in f.args) {
							var argName = arg.name;
							var argType = null;
							switch arg.type {
								case TPath(p): {
										argType = p.name;
										if (argType == "MandolinObject") {
											for (_p in p.params) {
												switch (_p) {
													case TPType(t): {
															switch (t) {
																case TPath(p): {
																		argType = 'const std::shared_ptr<${p.name}> &';  paramGetters.push('::mandolin_generated::Native${p.name}:fromCpp(jniEnv, $argName)');
																	}
																case _:
															}
														}
													case _:
												}
											}
										} else {
											switch p.name {
												case "String": argType = "const std::string &"; paramGetters.push('::mandolin::String::fromCpp(jniEnv, $argName)');
												case "Int" | "haxe.Int32": argType = "int32_t"; paramGetters.push('::mandolin::I32::fromCpp(jniEnv, $argName)');
												case "Int64": argType = "int64_t"; paramGetters.push('::mandolin::I64::fromCpp(jniEnv, $argName)');
												case "Float": argType = "double"; paramGetters.push('::mandolin::F64::fromCpp(jniEnv, $argName)');
												case "Bool": argType = "bool"; paramGetters.push('::mandolin::Bool::fromCpp(jniEnv, $argName)');
												case "IJavascriptArray": argType = "const std::shared_ptr<JavascriptArray> &"; paramGetters.push('::mandolin_generated::NativeJavascriptArray::fromCpp(jniEnv, $argName)');
												case "IJavascriptMap": argType = "const std::shared_ptr<JavascriptMap> &"; paramGetters.push('::mandolin_generated::NativeJavascriptMap::fromCpp(jniEnv, $argName)');
												case "IJavascriptCallback": argType = "const std::shared_ptr<JavascriptCallback> &"; paramGetters.push('::mandolin_generated::NativeJavascriptCallback::fromCpp(jniEnv, $argName)');
												case "IJavascriptObject": argType = "const std::shared_ptr<::JavascriptObject> &"; paramGetters.push('::mandolin_generated::NativeJavascriptObject::fromCpp(jniEnv, $argName)');
												case "IJobDispatcher": argType = "const std::shared_ptr<::JobDispatcher> &"; paramGetters.push('::mandolin_generated::NativeJobDispatcher::fromCpp(jniEnv, $argName)');
												case "IJob": argType = "const std::shared_ptr<::Job> &"; paramGetters.push('::mandolin_generated::NativeJob::fromCpp(jniEnv, $argName)');
												case "JobQueue": argType = "const std::shared_ptr<::JobQueue> &"; paramGetters.push('::mandolin_generated::NativeJobQueue::fromCpp(jniEnv, $argName)');
												case "JavascriptType": argType = "::JavascriptType";
												case "Array" | "ArrayList" | "NativeArray": {
														var _type = "";
														var getter = "";
														var rec = null;
														rec = ()->
														{
															for (_p in p.params) {
																switch (_p) {
																	case TPType(t): {
																			switch (t) {
																				case TPath(p): {
																						switch p.name {
																							case "String": _type = 'std::vector<string> &';  getter = '::mandolin::List<::mandolin::String>::fromCpp(jniEnv, $argName)';
																							case "Int": _type = 'std::vector<int32_t> &';  getter = '::mandolin::List<::mandolin::I32>::fromCpp(jniEnv, $argName)';
																							case "Int64": _type = 'std::vector<int64_t> &'; getter = '::mandolin::List<::mandolin::I64>::fromCpp(jniEnv, $argName)';
																							case "Float": _type = 'std::vector<double> &'; getter = '::mandolin::List<::mandolin::F64>::fromCpp(jniEnv, $argName)';
																							case "Bool": _type = 'std::vector<bool> &'; getter = '::mandolin::List<::mandolin::Bool>::fromCpp(jniEnv, $argName)';
																							case "Array" | "ArrayList" | "NativeArray": _type = 'std::vector<${rec().type}> &'; getter = '::mandolin::List<${rec().getter}>::fromCpp(jniEnv, $argName)';
																							case _: {
																								_type = 'std::vector< ${getCppTypes(p.name)} > &'; 
																								getter = '::mandolin::List<::mandolin_generated::Native${p.name}>::fromCpp(jniEnv, $argName)';
																								if(p.name.startsWith("I")){
																									getter = '::mandolin::List<::mandolin_generated::Native${p.name.substring(1)}>:fromCpp(jniEnv, $argName)';
																								} else {
																									getter = '::mandolin::List<::mandolin_generated::Native${p.name}>:fromCpp(jniEnv, $argName)';
																								}
																							}
																						}
																					}
																				case _:
																			}
																		}
																	case _:
																}
															}

															return {
																type:_type,
																getter: getter
															}

														}
														
														argType = rec().type;
														paramGetters.push(rec().getter);
														
													}
												case _:
											}
										}
									}

								case _:
							}
							params.push(['$argName', '$argType']);
						}
						var hasReturn = false;
						var _type = "";
						if (f.ret != null) {
							hasReturn = true;
							switch (f.ret) {
								case TPath(p): {
										if (p.name == "MandolinObject") {
											for (_p in p.params) {
												switch (_p) {
													case TPType(t): {
															switch (t) {
																case TPath(p): {
																		_type = 'std::shared_ptr<${p.name}>'; retGetters.push('::mandolin_generated::Native${p.name}:toCpp(jniEnv, ret)');
																	}
																case _:
															}
														}
													case _:
												}
											}
										} else {
											switch p.name {
												case "String": _type = "std::string"; retGetters.push('::mandolin::String:toCpp(jniEnv, ret)');
												case "Int" | "haxe.Int32": _type = "int32_t"; retGetters.push('::mandolin::I32:toCpp(jniEnv, ret)');
												case "Int64": _type = "int64_t"; retGetters.push('::mandolin::I64:toCpp(jniEnv, ret)');
												case "Float": _type = "double"; retGetters.push('::mandolin::F64:toCpp(jniEnv, ret)');
												case "Void": _type = "void"; hasReturn = false; 
												case "Bool": _type = "bool"; retGetters.push('::mandolin::Bool:toCpp(jniEnv, ret)');
												case "IJavascriptArray": _type = "std::shared_ptr<JavascriptArray>"; retGetters.push('::mandolin_generated::NativeJavascriptArray:toCpp(jniEnv, ret)');
												case "IJavascriptMap": _type = "std::shared_ptr<JavascriptMap>"; retGetters.push('::mandolin_generated::NativeJavascriptMap:toCpp(jniEnv, ret)');
												case "IJavascriptCallback": _type = "std::shared_ptr<JavascriptCallback>"; retGetters.push('::mandolin_generated::NativeJavascriptCallback:toCpp(jniEnv, ret)');
												case "IJavascriptObject": _type = "std::shared_ptr<::JavascriptObject>"; retGetters.push('::mandolin_generated::NativeJavascriptObject:toCpp(jniEnv, ret)');
												case "IJob": _type = "std::shared_ptr<::Job>"; retGetters.push('::mandolin_generated::NativeJob:toCpp(jniEnv, ret)');
												case "IJobDispatcher": _type = "std::shared_ptr<::JobDispatcher>"; retGetters.push('::mandolin_generated::NativeJobDispatcher:toCpp(jniEnv, ret)');
												case "JobQueue": _type = "std::shared_ptr<::JobQueue>"; retGetters.push('::mandolin_generated::NativeJobQueue:toCpp(jniEnv, ret)');
												case "JavascriptType": _type = "::JavascriptType";
												case "Array" | "ArrayList" | "NativeArray": {
													var xtype = "";
													var rtype = "";
													var rec = null;
													rec = ()->
													{
														for (_p in p.params) {
															switch (_p) {
																case TPType(t): {
																		switch (t) {
																			case TPath(p): {
																					switch p.name {
																						case "String": xtype = 'std::vector<string> &'; rtype = '::mandolin::List<::mandolin::String>:toCpp(jniEnv, ret)';
																						case "Int": xtype = 'std::vector<int32_t> &'; rtype = '::mandolin::List<::mandolin::I32>:toCpp(jniEnv, ret)';
																						case "Int64": xtype = 'std::vector<int64_t> &'; rtype = '::mandolin::List<::mandolin::I64>:toCpp(jniEnv, ret)';
																						case "Float": xtype = 'std::vector<double> &'; rtype = '::mandolin::List<::mandolin::F64>:toCpp(jniEnv, ret)';
																						case "Bool": xtype = 'std::vector<bool> &'; rtype = '::mandolin::List<::mandolin::Bool>:toCpp(jniEnv, ret)';
																						case "Array" | "ArrayList" | "NativeArray": _type = 'std::vector<${getTypes(rec().xtype)}> &'; rtype = '::mandolin::List<${getTypes(rec().rtype)}>:toCpp(jniEnv, ret)';
																						case _: {
																							xtype = 'std::vector< ${getTypes(p.name)} > &'; 
																							if(p.name.startsWith("I")){
																								rtype = '::mandolin::List<::mandolin_generated::Native${p.name.substring(1)}>:toCpp(jniEnv, ret)';
																							} else {
																								rtype = '::mandolin::List<::mandolin_generated::Native${p.name}>:toCpp(jniEnv, ret)';
																							}
																							
																						}
																					}
																				}
																			case _:
																		}
																	}
																case _:
															}
														}

														return 
														{
															xtype: xtype,
															rtype: rtype
														};
													}
													_type = rec().xtype;
													retGetters.push(rec().rtype);	
												}
												case _:
											}
										}
									}
								case _:
							}

							funcs.push('$_type $moduleName::JavaProxy::$fname(');
						} else {
							hasReturn = false;
							funcs.push('void $moduleName::JavaProxy::$fname(');
						}

						for (i in 0...params.length) {
							var param = params[i];
							var pname = param[0];
							var ptype = param[1];
							funcs.push('$ptype $pname');
							if (i < params.length - 1) {
								funcs.push(', ');
							}
						}
						funcs.push(') {\n');
						funcs.push('\tauto jniEnv = ::mandolin::jniGetThreadEnv();\n');
						funcs.push('\t::mandolin::JniLocalScope jscope(jniEnv, 10);\n');
						funcs.push('\tconst auto& data = ::mandolin::JniClass<::mandolin_generated::$moduleName>::get();\n');
						if(hasReturn)funcs.push('\tauto ret = jniEnv->CallObjectMethod(Handle::get().get(), data.method_$fname');
						else funcs.push('\tjniEnv->CallVoidMethod(Handle::get().get(), data.method_$fname');
						
						for (i in 0...paramGetters.length) {
							funcs.push(', ');
							var param = paramGetters[i];
							
							funcs.push(param);
							if (i < paramGetters.length - 1) {
								funcs.push(', ');
							}
						}
						funcs.push(');\n');
						funcs.push('\t::mandolin::jniExceptionCheck(jniEnv);\n');
						if(hasReturn)funcs.push('\treturn ${retGetters[0]};\n');
						funcs.push('}\n');
					}
				case _:
			}
		}

		for (func in funcs) {
			sbuf.add(func);
		}

		sbuf.add("}\n");

		File.saveContent(name, sbuf.toString());
	}

	static function getJNICppTypes(type:String) {
		return switch type {
			case "String": "jstring";
			case "Int" | "haxe.Int32": "jint";
			case "Int64": "jlong";
			case "Float": "jdouble";
			// case "Event": "::mandolin_generated::NativeJavascriptEvent::JniType";
			case "IJavascriptCallback": "::mandolin_generated::NativeJavascriptCallback::JniType";
			case "IJavascriptMap": "::mandolin_generated::NativeJavascriptMap::JniType";
			case "IJavascriptArray": "::mandolin_generated::NativeJavascriptArray::JniType";
			case "IJavascriptPromise": "::mandolin_generated::NativeJavascriptPromise::JniType";
			case "IJavascriptMapKeyIterator": "::mandolin_generated::NativeJavascriptMapKeyIterator::JniType";
			case "JavascriptType": "jint";
			case _: throw "Type not supported";
		}
	}

	static function getCppTypes(type:String) {
		return switch type {
			case "String": "string";
			case "Int" | "haxe.Int32": "int32_t";
			case "Int64": "int64_t";
			case "Float": "double";
			case "IJavascriptCallback": "std::shared_ptr<::JavascriptCallback> &";
			case "IJavascriptMap": "std::shared_ptr<::JavascriptMap> &";
			case "IJavascriptObject": "std::shared_ptr<::JavascriptObject> &";
			case "IJavascriptArray": "std::shared_ptr<::JavascriptArray> &";
			case "IJavascriptPromise": "std::shared_ptr<::JavascriptPromise> &";
			case "IJavascriptMapKeyIterator": "std::shared_ptr<::JavascriptMapKeyIterator> &";
			case "IJob": "std::shared_ptr<::Job> &";
			case "IJobDispatcher": "std::shared_ptr<::JobDispatcher> &";
			case "JobQueue": "std::shared_ptr<::JobQueue> &";
			case "JavascriptType": "::JavascriptObjectType";
			case _: throw "Type not supported";
		}
	}

	static function getTypes(type:String) {
		return switch type {
			case "String": "string";
			case "Int" | "haxe.Int32": "int32_t";
			case "Int64": "int64_t";
			case "Float": "double";
			case "Bool": "bool";
			case "IJavascriptCallback": "std::shared_ptr<::JavascriptCallback>";
			case "IJavascriptMap": "std::shared_ptr<::JavascriptMap>";
			case "IJavascriptObject": "std::shared_ptr<::JavascriptObject>";
			case "IJavascriptArray": "std::shared_ptr<::JavascriptArray>";
			case "IJavascriptPromise": "std::shared_ptr<::JavascriptPromise>";
			case "IJobDispatcher": "std::shared_ptr<::JobDispatcher>";
			case "IJavascriptMapKeyIterator": "std::shared_ptr<::JavascriptMapKeyIterator>";
			case "IJob": "std::shared_ptr<::Job>";
			case "JobQueue": "std::shared_ptr<::JobQueue>";
			case "JavascriptType": "::JavascriptObjectType";
			case _: throw "Type not supported";
		}
	}

	static function transformParams(type:String, arg:String) {
		return switch type {
			case "jstring": '::mandolin::String::toCpp(jniEnv, $arg)';
			case "jint" | "haxe.Int32": '::mandolin::I32::toCpp(jniEnv, $arg)';
			case "jlong": '::mandolin::I64::toCpp(jniEnv, $arg)';
			case "jdouble": '::mandolin::F64::toCpp(jniEnv, $arg)';
			case "::mandolin_generated::NativeJavascriptEvent::JniType": '::mandolin_generated::NativeJavascriptEvent::toCpp(jniEnv, $arg)';
			case "::mandolin_generated::NativeJavascriptCallback::JniType": '::mandolin_generated::NativeJavascriptCallback::toCpp(jniEnv, $arg)';
			case "::mandolin_generated::NativeJavascriptMap::JniType": '::mandolin_generated::NativeJavascriptMap::toCpp(jniEnv, $arg)';
			case "::mandolin_generated::NativeJavascriptArray::JniType": '::mandolin_generated::NativeJavascriptArray::toCpp(jniEnv, $arg)';
			case "::mandolin_generated::NativeJavascriptPromise::JniType": '::mandolin_generated::NativeJavascriptPromise::toCpp(jniEnv, $arg)';
			case _: throw "Type not supported";
		}
	}

	static function constructJNIHeader(name:String) {
		var sbuf = new StringBuf();
		var pack = Context.getLocalModule();
		var unpack = pack.split(".");
		var pathLength = unpack.length;
		var _name = '${unpack[pathLength - 1]}';
		var nHeader = pack.replace(".", "/");
		var _package = unpack.slice(0, pathLength - 1).join("/");

		var funcs:Array<String> = [];
		var imports:Array<String> = [];

		var fields:Array<Field> = Context.getBuildFields();

		for (field in fields) {
			switch (field.kind) {
				case FFun(f):
					{
						var hasIgnore = false; 
						for (meta in field.meta){
							if(meta.name == "ignore"){
								hasIgnore = true;
							}
						}
						if(hasIgnore) continue;

						var impName = "";
						var re = ~/([-_][a-z])/;
						var fname = field.name;
						if (re.match(field.name)) {
							for (i in 0...re.matchedPos().len) {
								fname = re.replace(field.name, re.matched(i).toUpperCase()).replace("_", "").replace("-", "");
							}
						}

						if (fname == "new") {
							continue;
						}

						var params = [];
						for (arg in f.args) {
							var argName = arg.name;
							var argType = null;
							switch arg.type {
								case TPath(p): {
										argType = p.name;
										if (argType == "MandolinObject") {
											for (_p in p.params) {
												switch (_p) {
													case TPType(t): {
															switch (t) {
																case TPath(p): {
																		impName = '#include <co/zenturi/mandolin/xnative/${p.name}.h>\n';
																		argType = 'const std::shared_ptr<${p.name}> &';
																	}
																case _:
															}
														}
													case _:
												}
											}
										} else {
											switch p.name {
												case "String": argType = "const std::string &";
												case "Int" | "haxe.Int32": argType = "int32_t";
												case "Int64": argType = "int64_t";
												case "Float": argType = "double";
												case "Bool": argType = "bool";
												case "IJavascriptCallback": argType = "const std::shared_ptr<::JavascriptCallback> &";
												case "IJavascriptMap": argType = "const std::shared_ptr<::JavascriptMap> &";
												case "IJavascriptArray": argType = "const std::shared_ptr<::JavascriptArray> &";
												case "IJavascriptPromise": argType = "const std::shared_ptr<::JavascriptPromise> &";
												case "IJavascriptObject": argType = "const std::shared_ptr<::JavascriptObject> &";
												case "IJavascriptMapKeyIterator": argType = "const std::shared_ptr<::JavascriptMapKeyIterator> &";
												case "IJobDispatcher": argType = "const std::shared_ptr<::JobDispatcher> &";
												case "IJob": argType = "const std::shared_ptr<::Job> &";
												case "JobQueue": argType = "const std::shared_ptr<::JobQueue> &";
												case "JavascriptType": argType = "::JavascriptType";
												case "Array" | "ArrayList" | "NativeArray": {
													var _type = "";
													var rec:Void->String = () -> "";
													rec = ()->
													{
														for (_p in p.params) {
															switch (_p) {
																case TPType(t): {
																		switch (t) {
																			case TPath(p): {
																					switch p.name {
																						case "String": _type = 'const std::vector<string> &';
																						case "Int": _type = 'const std::vector<int32_t> &';
																						case "Int64": _type = 'const std::vector<int64_t> &';
																						case "Float": _type = 'const std::vector<double> &';
																						case "Bool": _type = 'const std::vector<bool> &';
																						case "Array" | "ArrayList" | "NativeArray": _type = 'const std::vector<${rec()}> &';
																						case _: _type = 'const std::vector< ${getTypes(p.name)} > &';
																					}
																				}
																			case _:
																		}
																	}
																case _:
															}
														}

														return _type;
													}
													argType = rec();
													
												}
												case _:
											}
										}
									}
								case _:
							}
							
							// argType = getCppTypes(argType);
							params.push(['$argName', '$argType']);

							if (imports.indexOf(impName) == -1) {
								imports.push(impName);
							}
						}

						var hasPromise = false;
						var _type = "";
						if (f.ret != null) {
							switch (f.ret) {
								case TPath(p): {
										if (p.name == "MandolinObject") {
											for (_p in p.params) {
												switch (_p) {
													case TPType(t): {
															switch (t) {
																case TPath(p): {
																		impName = '#include <co/zenturi/mandolin/xnative/${p.name}.h>\n';
																		_type = 'std::shared_ptr<${p.name}>';
																	}
																case _:
															}
														}
													case _:
												}
											}
										} else {
											switch p.name {
												case "String": _type = "std::string";
												case "Int" | "haxe.Int32": _type = "int32_t";
												case "Int64": _type = "int64_t";
												case "Float": _type = "double";
												case "Void": _type = "void";
												case "Bool": _type = "bool";
												case "IJavascriptCallback": _type =  "std::shared_ptr<::JavascriptCallback>";
												case "IJavascriptMap": _type = "std::shared_ptr<::JavascriptMap>";
												case "IJavascriptArray": _type ="std::shared_ptr<::JavascriptArray>";
												case "IJavascriptPromise": _type = "std::shared_ptr<::JavascriptPromise>";
												case "IJavascriptObject": _type = "std::shared_ptr<::JavascriptObject>";
												case "IJobDispatcher": _type = "std::shared_ptr<::JobDispatcher>";
												case "JobQueue": _type = "std::shared_ptr<::JobQueue>";
												case "IJavascriptMapKeyIterator": _type = "std::shared_ptr<::JavascriptMapKeyIterator>";
												case "IJob": _type = "std::shared_ptr<::Job>";
												case "JavascriptType": _type = "::JavascriptType";
												case "Array" | "ArrayList" | "NativeArray": {
													var xtype = "";
													var rec:Void->String = () -> "";
													rec = ()->
													{
														for (_p in p.params) {
															switch (_p) {
																case TPType(t): {
																		switch (t) {
																			case TPath(p): {
																					switch p.name {
																						case "String": xtype = 'std::vector<string> &';
																						case "Int": xtype = 'std::vector<int32_t> &';
																						case "Int64": xtype = 'std::vector<int64_t> &';
																						case "Float": xtype = 'std::vector<double> &';
																						case "Bool": xtype = 'std::vector<bool> &';
																						case "Array" | "ArrayList" | "NativeArray": xtype = 'std::vector<${rec()}> &';
																						case _: xtype = 'std::vector< ${getTypes(p.name)} > &';
																					}
																				}
																			case _:
																		}
																	}
																case _:
															}
														}

														return xtype;
													}
													_type = rec();
													
												}
												case _:
											}
										}
									}
								case _:
							}
							funcs.push('\t\t\t$_type $fname(');
						} else {
							funcs.push('\t\t\tvoid $fname(');
						}

						// if (params.length > 0)
						// 	funcs.push(', ');
						for (i in 0...params.length) {
							var param = params[i];
							var pname = param[0];
							var ptype = param[1];
							funcs.push('$ptype $pname');
							if (i < params.length - 1) {
								funcs.push(', ');
							}
						}
						funcs.push(') override;\n');
					};
				case _:
			}
		}

		sbuf.add("// AUTOGENERATED FILE - DO NOT MODIFY!\n");
		sbuf.add("// This file is generated by Mandolin - (c) Zenturi.co\n\n");
		sbuf.add("#pragma once\n\n");
		sbuf.add('#include <$_package/I$_name.h>\n\n');
		// sbuf.add('#include "$_name.hpp"\n\n');
		sbuf.add('#include <mandolin_helpers.h>\n\n');
		sbuf.add("namespace mandolin_generated {\n\n");
		sbuf.add('class $moduleName final : ::mandolin::JniInterface<::$_name, $moduleName> {\n');
		sbuf.add('public:\n');
		sbuf.add('\tusing CppType = std::shared_ptr<::$_name>;\n');
		sbuf.add('\tusing CppOptType = std::shared_ptr<::$_name>;\n');
		sbuf.add('\tusing JniType = jobject;\n');
		sbuf.add('\tusing Boxed = $moduleName;\n\n');
		sbuf.add('\t~$moduleName(){};\n\n');
		sbuf.add('\tstatic CppType toCpp(JNIEnv* jniEnv, JniType j) { return ::mandolin::JniClass<$moduleName>::get()._fromJava(jniEnv, j); }\n');
		sbuf.add('\tstatic ::mandolin::LocalRef<JniType> fromCppOpt(JNIEnv* jniEnv, const CppOptType& c) { return {jniEnv, ::mandolin::JniClass<$moduleName>::get()._toJava(jniEnv, c)}; }\n');
		sbuf.add('\tstatic ::mandolin::LocalRef<JniType> fromCpp(JNIEnv* jniEnv, const CppType& c) { return fromCppOpt(jniEnv, c); }\n\n');
		sbuf.add('private:\n');
		sbuf.add('\t$moduleName(){};\n');
		sbuf.add('\tfriend ::mandolin::JniClass<$moduleName>;\n');
		sbuf.add('\tfriend ::mandolin::JniInterface<::$_name, $moduleName>;\n\n');
		// Java proxy
		sbuf.add('\tclass JavaProxy final : ::mandolin::JavaProxyHandle<JavaProxy>, public ::$_name {\n');
		sbuf.add('\t\tpublic:\n');
		sbuf.add('\t\t\tJavaProxy(JniType j);\n');
		sbuf.add('\t\t\t~JavaProxy();\n');
		for (func in funcs) {
			sbuf.add(func);
		}
		sbuf.add('\t\tprivate:\n');
		sbuf.add('\t\t\tfriend ::mandolin::JniInterface<::$_name, ::mandolin_generated::$moduleName>;\n');
		sbuf.add('\t};\n\n');

		sbuf.add('\tconst ::mandolin::GlobalRef<jclass> clazz { ::mandolin::jniFindClass("$_package/react/$_name") };\n');
		JNIMethods(sbuf);
		sbuf.add('};\n\n');
		sbuf.add("} // namespace mandolin_generated \n");
		File.saveContent(name, sbuf.toString());
	}

	static function JNIMethods(sbuf:StringBuf) {
		var pack = Context.getLocalModule();
		var unpack = pack.split(".");
		var pathLength = unpack.length;
		var _name = '${unpack[pathLength - 1]}';
		var nHeader = pack.replace(".", "/");
		var _package = unpack.slice(0, pathLength - 1).join("/");

		var funcs:Array<String> = [];

		var fields:Array<Field> = Context.getBuildFields();

		for (field in fields) {
			switch (field.kind) {
				case FFun(f):
					{
						var hasIgnore = false; 
						for (meta in field.meta){
							if(meta.name == "ignore"){
								hasIgnore = true;
							}
						}
						if(hasIgnore) continue;

						var re = ~/([-_][a-z])/;
						var fname = field.name;
						if (re.match(field.name)) {
							for (i in 0...re.matchedPos().len) {
								fname = re.replace(field.name, re.matched(i).toUpperCase()).replace("_", "").replace("-", "");
							}
						}

						if (fname == "new") {
							continue;
						}

						var params = [];
						for (arg in f.args) {
							switch arg.type {
								case TPath(p): {
										if (p.name == "MandolinObject") {
											for (_p in p.params) {
												switch (_p) {
													case TPType(t): {
															switch (t) {
																case TPath(p): {
																		params.push('L$_package/react/${p.name};');
																	}
																case _:
															}
														}
													case _:
												}
											}
										} else {
											var _type = "";
											switch p.name {
												case "String": _type = "Ljava/lang/String;";
												case "Int" | "haxe.Int32": _type = "I";
												case "Int64": _type = "J";
												case "Float": _type = "D";
												case "Void": _type = "V";
												case "Bool": _type = "Z";
												case "Dynamic": _type = "Ljava.lang.Object";
												case "Array" | "ArrayList" | "NativeArray": _type = "Ljava/util/ArrayList;";

											}
											params.push('$_type');
										}
									}
								case _:
							}
						}

						if (f.ret != null) {
							switch (f.ret) {
								case TPath(p): {
										if (p.name == "MandolinObject") {
											for (_p in p.params) {
												switch (_p) {
													case TPType(t): {
															switch (t) {
																case TPath(p): {
																		sbuf.add('\tconst jmethodID method_$fname { ::mandolin::jniGetMethodID(clazz.get(), "$fname", "(${params.join(" ")})L$_package/react/${p.name};") };\n');
																	}
																case _:
															}
														}
													case _:
												}
											}
										} else {
											var _type = "";
											switch p.name {
												case "String": _type = "Ljava/lang/String;";
												case "Int" | "haxe.Int32": _type = "I";
												case "Int64": _type = "J";
												case "Float": _type = "D";
												case "Void": _type = "V";
												case "Bool": _type = "Z";
												case "Array" | "ArrayList" | "NativeArray": _type = "Ljava/util/ArrayList;";
											}

											sbuf.add('\tconst jmethodID method_$fname { ::mandolin::jniGetMethodID(clazz.get(), "$fname", "(${params.join(" ")})$_type") };\n');
										}

										//
									}
								case _:
							}
						}
					}
				case _:
			}
		}
	}


}
